var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#ConnectionPools.ConnectionPool","page":"API","title":"ConnectionPools.ConnectionPool","text":"ConnectionPool{T}(limit::Int) where T -> GenericPool{T}\n\nAlias for GenericPool{T}.\n\nThis function is an alias for GenericPool{T} and is provided for convenience.  It creates a new resource pool for resources of type T with a maximum concurrency limit of limit.\n\nArguments\n\nlimit::Int: The maximum number of resources allowed in the pool. Must be a positive integer.\n\nThrows\n\nArgumentError: If limit is not a positive integer.\n\n\n\n\n\n","category":"type"},{"location":"api/#ConnectionPools.GenericPool","page":"API","title":"ConnectionPools.GenericPool","text":"GenericPool{T}(limit::Int)\n\nA thread-safe resource pool manager for resources of type T.\n\nThis struct implements a resource pool, managing the acquisition and release of resources with a maximum concurrency limit.  It's designed to be used with various resource types, such as database connections or other objects that need to be managed and reused efficiently.\n\nType Parameters\n\nT: The type of resource managed by the pool.\n\nFields\n\nlimit::Int: The maximum number of resources that can be in use concurrently.\nfree::Vector{T}: A vector containing the currently available (free) resources in the pool.\ntaken::Set{T}: A set containing the resources that are currently in use (taken) by users.\nlock::ReentrantLock: A reentrant lock used for thread safety.  All operations on the pool are protected by this lock.\ncondition::Threads.Condition: A condition variable used to notify waiting tasks when a resource becomes available.\n\nConstructor\n\nGenericPool{T}(limit::Int) where T\nCreates a new resource pool for resources of type T with a maximum concurrency limit of limit.\n\n# Arguments\nlimit::Int: The maximum number of resources allowed in the pool. Must be a positive integer.\n\n# Throws\nArgumentError: If limit is not a positive integer.\n\n# Example\n\n\njulia using Pools, Redis, Dates\n\nstruct Connection     client::RedisConnection     timestamp::DateTime end\n\npool = GenericPool{Connection}(3) ```\n\n\n\n\n\n","category":"type"},{"location":"api/#ConnectionPools.acquire!-Union{Tuple{ConnectionPools.Pool{T}}, Tuple{T}} where T","page":"API","title":"ConnectionPools.acquire!","text":"acquire!(pool::Pool{T}) where T -> T\n\nAcquire a resource from the pool.\n\nThis function attempts to retrieve a resource from the pool.  It will reuse valid cached resources if available, create new resources if the pool is below its limit, or block until a resource becomes available if the pool is at its limit and no valid cached resources are available.\n\nArguments\n\npool::Pool{T}: The resource pool to acquire from.\n\nReturns\n\nA resource of type T.\n\nThrows\n\nMethodError: If the create(::Type{T}) function is not implemented for the resource type T.  This function is essential for the Pool to create new resources when needed.  See the documentation for create for more details.\nExceptions thrown by the check(resource::T) function. If check throws an exception, the resource is considered invalid and discarded.\n\nThread Safety\n\nThis operation is thread-safe.\n\nExample\n\nusing Redis, Dates\n\nstruct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\ncreate(::Type{Connection}) = Connection(RedisConnection(host = \"localhost\", port = 6379, db = 3), now())\ncheck(redis::Connection) = ping(redis.client)\n\npool = ConnectionPool{Connection}(3)\nconn = acquire!(pool)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.change!-Tuple{T} where T","page":"API","title":"ConnectionPools.change!","text":"change!(resource::T) where T\n\nChange the state of a resource of type T during releasing before it is reused.\n\nThis function is called automatically by the pool when a resource is returned to the pool via release!.  It provides an opportunity to update the resource's internal state, such as resetting connection parameters, change timestamps, etc.\n\nYou should implement this method if your resource requires any state changes before it can be reused.  If no update is needed, you can leave this method unimplemented, and the default implementation will do nothing.\n\nArguments\n\nresource::T: The resource to modify.\n\nGeneric Method\n\nA generic change!(::T) where T method is provided, which does nothing. This serves as a default implementation so that if you do not define a specific change! method for your resource type. However, it is strongly recommended that you implement a specific change! method if your resource requires any state changes.\n\nExample\n\nusing Pools, Redis, Dates\nimport Pools: create, change!\n\nmutable struct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\nfunction change!(redis::Connection)\n    redis.timestamp = now()\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.check-Tuple{T} where T","page":"API","title":"ConnectionPools.check","text":"check(resource::T) where T\n\nCheck the validity of a resource of type T.\n\nThis function is called automatically by the pool during resource acquisition (acquire!).  If check fails, the resource is considered invalid, and the pool will attempt to create a new resource (or retrieve another free resource).  It is essential to implement this method to ensure that the pool only provides valid resources to users.\n\nArguments\n\nresource::T: The resource to validate.\n\nGeneric Method\n\nA generic check(::T) where T method is provided, which does nothing.  This means that if you do not define a specific check method for your resource type, all resources will be considered valid.  While this might seem convenient, it is strongly recommended that you implement a specific check method that performs appropriate checks for your resource type.  Relying on the generic method without proper validation can lead to unexpected errors and resource leaks.\n\nExample\n\nusing Pools, Redis, Dates\nimport Pools: create, check\n\nstruct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\nfunction check(redis::Connection)\n    ping(redis.client)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.clean!-Tuple{T} where T","page":"API","title":"ConnectionPools.clean!","text":"clean!(resource::T) where T\n\nClean up resources associated with a resource of type T.\n\nThis function is called automatically by the pool in the following situations:\n\nWhen a resource fails validation (as determined by the check function).\nWhen a resource is removed from the pool (e.g., during pool draining or when the pool's limit is reduced).\n\nYou should implement this method to release any external resources held by the resource (e.g., closing connections, freeing memory, etc.).  If you do not implement this method, the default implementation will do nothing.\n\nArguments\n\nresource::T: The resource to clean up.\n\nGeneric Method\n\nA generic clean!(::T) where T method is provided, which does nothing. It is strongly recommended that you implement a specific clean! method if your resource requires any cleanup.\n\nExample\n\nusing Pools, Redis, Dates\nimport Pools: create, clean!\n\nstruct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\nfunction clean!(redis::Connection)\n    Redis.disconnect(redis.client)\nend\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.create-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"API","title":"ConnectionPools.create","text":"create(::Type{T}) where T -> T\n\nCreate a new instance of type T.\n\nThis function is called automatically by the pool when a new resource is needed (e.g., when a resource is acquired and the pool is empty or below its limit).  You must implement this method for any type T that you want to store in a Pool.\n\nArguments\n\n::Type{T}: The type of the resource to create.  This is a type parameter, not an instance of the type.\n\nReturns\n\nA new resource of type T.\n\nThrows\n\nMethodError: If this function is not implemented for the given type T.\n\nExample\n\n\nusing Pools, Redis, Dates\nimport Pools: create\n\nstruct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\ncreate(::Type{Connection}) = Connection(RedisConnection(host = \"localhost\", port = 6379, db = 3), now())\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.drain!-Union{Tuple{ConnectionPools.Pool{T}}, Tuple{T}} where T","page":"API","title":"ConnectionPools.drain!","text":"drain!(pool::Pool{T}) where T\n\nDrain the resource pool, releasing and finalizing all resources.\n\nThis function releases all resources currently held by the pool, both free and taken. It waits for all taken resources to be released back to the pool before finalizing them. This is typically used when you want to shut down the pool or when you need to ensure that all resources are properly cleaned up.\n\nArguments\n\npool::Pool{T}: The resource pool to drain.\n\nThread Safety\n\nThis operation is thread-safe.\n\nExample\n\nusing Redis, Dates\n\nstruct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\ncreate(::Type{Connection}) = Connection(RedisConnection(host = \"localhost\", port = 6379, db = 3), now())\nclean!(redis::Connection) = Redis.disconnect(redis.client)\n\npool = ConnectionPool{Connection}(3)\n\nwithresource(pool) do redis\n    ping(redis.client)\nend\n\ndrain!(pool)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.free-Union{Tuple{ConnectionPools.Pool{T}}, Tuple{T}} where T","page":"API","title":"ConnectionPools.free","text":"free(pool::Pool{T}) where T -> Int\n\nReturn the number of free resources currently available in the pool.\n\nThis function provides a thread-safe way to check how many resources are currently available for immediate acquisition in the pool. It does not include resources that are currently in use (taken).\n\nArguments\n\npool::Pool{T}: The resource pool to query.\n\nReturns\n\nThe number of free resources in the pool.\n\nThread Safety\n\nThis operation is thread-safe.\n\nExample\n\nusing Pools\n\ncreate(::Type{Int}) = rand(1:10)\n\npool = GenericPool{Int}(3)\nfree(pool)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.limit-Union{Tuple{ConnectionPools.Pool{T}}, Tuple{T}} where T","page":"API","title":"ConnectionPools.limit","text":"limit(pool::Pool{T}) where T -> Int\n\nReturn the maximum number of resources that the pool can hold concurrently.\n\nThis function returns the limit of the pool, which represents the maximum number of resources that can be in use (taken) at any given time.\n\nArguments\n\npool::Pool{T}: The resource pool to query.\n\nReturns\n\nThe maximum number of concurrent resources allowed by the pool.\n\nThread Safety\n\nThis operation is thread-safe.  Access to the pool.limit field is inherently atomic in Julia.\n\nExample\n\nusing Pools\n\ncreate(::Type{Int}) = rand(1:10)\n\npool = GenericPool{Int}(5)\nlimit(pool)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.release!-Union{Tuple{T}, Tuple{ConnectionPools.Pool{T}, T}} where T","page":"API","title":"ConnectionPools.release!","text":"release!(pool::Pool{T}, resource::T)\n\nRelease a resource back to the pool.\n\nThis function returns a resource to the pool, making it available for reuse.  It changes the resource's state (using the change! function) and notifies any waiting tasks that a resource has become available.\n\nArguments\n\npool::Pool{T}: The resource pool to release the resource to.\nresource::T: The resource to release.\n\nThrows\n\nArgumentError: If the provided resource does not belong to the pool (i.e., it was not acquired from this pool).\nExceptions thrown by the change!(resource::T) function.\n\nThread Safety\n\nThis operation is thread-safe.\n\nExample\n\nusing Redis, Dates\n\nstruct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\ncreate(::Type{Connection}) = Connection(RedisConnection(host = \"localhost\", port = 6379, db = 3), now())\nchange!(redis::Connection) = redis.timestamp = now()\n\npool = ConnectionPool{Connection}(3)\nconn = acquire!(pool)\nrelease!(pool, conn)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.taken-Union{Tuple{ConnectionPools.Pool{T}}, Tuple{T}} where T","page":"API","title":"ConnectionPools.taken","text":"taken(pool::Pool{T}) where T -> Int\n\nReturn the number of resources currently taken (in use) from the pool.\n\nThis function provides a thread-safe way to check how many resources are currently in use (taken) from the pool.  It does not include resources that are free and available for immediate acquisition.\n\nArguments\n\npool::Pool{T}: The resource pool to query.\n\nReturns\n\nThe number of taken resources in the pool.\n\nThread Safety\n\nThis operation is thread-safe.\n\nExample\n\nusing Pools\n\ncreate(::Type{Int}) = rand(1:10)\n\npool = GenericPool{Int}(3)\ntaken(pool)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConnectionPools.withresource-Union{Tuple{T}, Tuple{Any, ConnectionPools.Pool{T}}} where T","page":"API","title":"ConnectionPools.withresource","text":"withresource(f::Function, pool::Pool{T}) where T\n\nExecute a function with a resource from the pool, automatically handling acquisition and release.\n\nThis function provides a safe and convenient way to use resources from the pool.  It acquires a resource, passes it to the provided function f, and guarantees that the resource is released back to the pool, even if an error occurs within the function.  This is the recommended way to work with pooled resources, as it prevents resource leaks and simplifies resource management.\n\nArguments\n\nf::Function: A function that accepts a resource of type T as its argument. This function performs the operations you want to do with the resource.\npool::Pool{T}: The resource pool to acquire the resource from.\n\nReturns\n\nThe value returned by the function f.\n\nThrows\n\nExceptions thrown by the function f.  These exceptions will be propagated after the resource is released.\nMethodError: If the create(::Type{T}) or check(resource::T) functions are not implemented for the resource type T.\n\nExample\n\n\nusing Redis, Dates\n\nstruct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\ncreate(::Type{Connection}) = Connection(RedisConnection(host = \"localhost\", port = 6379, db = 3), now())\n\npool = ConnectionPool{Connection}(3)\n\nwithresource(pool) do redis\n    ping(redis.client)\nend\n\n\n\n\n\n","category":"method"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This page provides detailed instructions on how to use the ConnectionPools.jl package, including explanations of key concepts, API documentation for all exported functions and types, and examples of common usage patterns.","category":"page"},{"location":"usage/#Core-Concepts","page":"Usage","title":"Core Concepts","text":"","category":"section"},{"location":"usage/#Resource-Pools","page":"Usage","title":"Resource Pools","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"A resource pool is a collection of resources that are managed and reused to improve performance.  Instead of creating new resources every time they are needed, a pool maintains a set of available resources and distributes them as requested.  When a resource is no longer needed, it is returned to the pool for later reuse, avoiding the overhead of creating and destroying resources repeatedly.","category":"page"},{"location":"usage/#Resource-Lifecycle","page":"Usage","title":"Resource Lifecycle","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Resources managed by ConnectionPools.jl go through a specific lifecycle:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Creation: New resources are created using the create(::Type{T}) function.\nAcquisition: Resources are acquired from the pool using the acquire!(pool::ConnectionPool{T}) function.\nValidation: Before a resource is given to a user, it is validated using the check(resource::T) function to ensure it is still valid.\nUsage: The resource is used by the application.\nUpdate: Before a resource is returned to the pool, its state can be updated using the change!(resource::T) function.\nRelease: Resources are returned to the pool using the release!(pool::ConnectionPool{T}, resource::T) function.\nFinalization: Resources are finalized (cleaned up) using the clean!(resource::T) function when they are no longer needed by the pool (e.g., during pool draining or when they fail validation).","category":"page"},{"location":"usage/#Using-the-Pool","page":"Usage","title":"Using the Pool","text":"","category":"section"},{"location":"usage/#Creating-a-Pool","page":"Usage","title":"Creating a Pool","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"To create a resource pool, you need to define your resource type T and implement the create, check, change!, and clean! functions for that type. Then, you can create a pool using the ConnectionPool{T}(limit::Int) constructor.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using ConnectionPools\nimport ConnectionPools: create, check, change!, clean!\n\n# Implement the required functions\ncreate(::Type{T}) = T()\ncheck(::T) = println(\"Resource validated\") # How to validate\nchange!(::T) = println(\"Resource updated\") # How to update\nclean!(::T) = println(\"Resource finalized\") # How to finalize\n\npool = ConnectionPool{T}(5) # Create a pool with a maximum of 5 resources","category":"page"},{"location":"usage/#Acquiring-a-Resource","page":"Usage","title":"Acquiring a Resource","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"To acquire a resource from the pool, use the acquire!(pool::ConnectionPool{T}) function.  This function will either return a free resource from the pool, create a new resource (if below the limit), or block until a resource becomes available.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"resource = acquire!(pool)\n# ... use the resource ...","category":"page"},{"location":"usage/#Releasing-a-Resource","page":"Usage","title":"Releasing a Resource","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"To release a resource back to the pool, use the release!(pool::ConnectionPool{T}, resource::T) function.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"release!(pool, resource)","category":"page"},{"location":"usage/#Using-withconnection-(Recommended)","page":"Usage","title":"Using withconnection (Recommended)","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The recommended way to work with pooled resources is to use the withconnection(f::Function, pool::ConnectionPool{T}) function.  This function automatically acquires a resource, passes it to your function f, and ensures that the resource is released back to the pool, even if errors occur.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"withconnection(pool) do resource\n    # ... use the resource ...\nend # Resource is automatically released here","category":"page"},{"location":"usage/#Draining-the-Pool","page":"Usage","title":"Draining the Pool","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"To release and finalize all resources in the pool, use the drain!(pool::ConnectionPool{T}) function.  This is typically done when you want to shut down the pool.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"drain!(pool)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"API @autodoc(Pools)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This page provides more detailed examples of how to use Pools.jl to manage different types of resources.","category":"page"},{"location":"examples/#Example:-SQLite-Connection-Pooling","page":"Examples","title":"Example: SQLite Connection Pooling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates how to use ConnectionPools.jl to manage a pool of SQLite.jl database connections.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using DBInterface, DataFrames, SQLite\n\n# Connect to SQLite database\ndb = SQLite.DB(\"database.db\")\n\n# Create table if it doesn't exist\nDBInterface.execute(db, \"CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\")\n\n# Begin a transaction to speed up batch inserts\nDBInterface.execute(db, \"BEGIN TRANSACTION\")\n\n# Insert 1000 records into the users table\nfor i in 1:1000\n    name = \"User$i\"\n    age = rand(20:60)  # Random age between 20 and 60\n    DBInterface.execute(db, \"INSERT INTO users (name, age) VALUES (?, ?)\", (name, age,))\nend\n\n# Commit transaction\nDBInterface.execute(db, \"COMMIT\")\n\n# Close database connection\nDBInterface.close!(db)\n\nusing ConnectionPools\nimport ConnectionPools: create, clean!\n\n# Implement the required functions\ncreate(::Type{SQLite.DB}) = SQLite.DB(\"database.db\")\nclean!(db::SQLite.DB) = DBInterface.close!(db)\n\n# Create a pool of connections with a maximum of 5 connections\npool = ConnectionPool{SQLite.DB}(3)\n\n# Use a connection from the pool\n@time Threads.@threads for i in 1:20\n    withconnection(pool) do db\n        df = DBInterface.execute(db, \"SELECT * FROM users LIMIT $i\") |> DataFrame\n        @info \"Thread $(Threads.threadid()) - Number of rows: $(nrow(df))\"\n    end\nend\n\n# Drain the pool (release and finalize all resources)\ndrain!(pool)","category":"page"},{"location":"examples/#Example:-Redis-Connection-Pooling","page":"Examples","title":"Example: Redis Connection Pooling","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates how to use ConnectionPools.jl to manage a pool of Redis.jl database connections.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ConnectionPools, Dates, Redis\nimport ConnectionPools: create, clean!, check, change! # Functions to be extended\n\nmutable struct Connection\n    client::RedisConnection\n    timestamp::DateTime\nend\n\n# Implement the required functions\ncreate(::Type{Connection}) = Connection(RedisConnection(host = \"localhost\", port = 6379, db = 3), now())\ncheck(conn::Connection) = ping(conn.client)\nchange!(conn::Connection) = conn.timestamp = now()\nclean!(conn::Connection) = disconnect(conn.client)\n\n# Create a pool of connections with a maximum of 5 connections\npool = ConnectionPool{Connection}(5)\n\n# Use a connection from the pool (using withconnection is recommended)\nwithconnection(pool) do conn\n    # ... use the connection ...\n    get(conn.client, \"key\")\nend # The connection is automatically released back to the pool here\n\n# Or, acquire and release manually (less recommended):\nconn = acquire!(pool)\n# ... use the connection ...\nget(conn.client, \"key\")\nrelease!(pool, conn)\n\n# Drain the pool (release and finalize all resources)\ndrain!(pool)","category":"page"},{"location":"#Pools.jl","page":"Introduction","title":"Pools.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"ConnectionPools.jl provides a generic and thread-safe resource pooling mechanism for Julia.  It's designed to efficiently manage and reuse resources of any type T, such as database connections, network sockets, or other expensive-to-create objects.  This can significantly improve the performance of applications that require access to multiple resources concurrently.","category":"page"},{"location":"#Key-Features","page":"Introduction","title":"Key Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Generic:  Works with any resource type T.  You define how to create, check, change, and clean resources, and ConnectionPools.jl handles the rest.\nThread-safe:  All operations are thread-safe, allowing concurrent access to the pool from multiple tasks.\nResource Management:  Handles resource creation, validation, allocation, and deallocation, limiting the number of resources in use concurrently.\nAutomatic Cleanup: Provides mechanisms for cleaning up resources when they are no longer needed (e.g., when the pool is drained or when resources fail validation).\nConvenient withconnection Function: Simplifies the process of acquiring and using resources, ensuring they are automatically released back to the pool, even if errors occur.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"] add ConnectionPools","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using ConnectionPools, Redis\nimport ConnectionPools: create # Functions to be extended\n\n# Implement the required functions\ncreate(::Type{RedisConnection}) = RedisConnection(host = \"localhost\", port = 6379, db = 3)\n\n# Create a pool of connections with a maximum of 5 connections\npool = ConnectionPool{RedisConnection}(5)\n\n# Use a connection from the pool (using withconnection is recommended)\nwithconnection(pool) do conn\n    ping(conn)\n    # ... use the connection ...\nend # The connection is automatically released back to the pool here\n\n# Or, acquire and release manually (less recommended):\nconn = acquire!(pool)\n# ... use the connection ...\nping(conn)\nrelease!(pool, conn)\n\n# Drain the pool (release and finalize all resources)\ndrain!(pool)","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For detailed usage instructions and API documentation, please see the Usage page.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"More comprehensive examples demonstrating various use cases and features can be found on the Examples page.","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The full API documentation, including all functions and types, is available on the API page.","category":"page"},{"location":"#Contributing","page":"Introduction","title":"Contributing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Contributions are welcome! Please see the Contributing page for guidelines.","category":"page"},{"location":"#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package is distributed under the MIT License.","category":"page"}]
}
